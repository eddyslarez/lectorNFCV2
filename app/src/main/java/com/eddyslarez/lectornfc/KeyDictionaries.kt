package com.eddyslarez.lectornfc

import android.nfc.tech.MifareClassic

// KeyDictionaries.kt
class KeyDictionaries {
    // Российские домофонные ключи
    private val russianDomophoneKeys = listOf(
        byteArrayOf(0x48, 0x52, 0x4D, 0x43, 0x34, 0x30), // HRM домофоны
        byteArrayOf(0x31, 0x32, 0x33, 0x34, 0x35, 0x36), // Стандартные коды
        byteArrayOf(0x44, 0x4F, 0x4D, 0x4F, 0x46, 0x4F), // "DOMOFON"
        byteArrayOf(0x45, 0x4C, 0x45, 0x43, 0x54, 0x52), // "ELECTR"
        byteArrayOf(0x54, 0x52, 0x4F, 0x4E, 0x49, 0x4B), // "TRONIK"
        byteArrayOf(0x4D, 0x45, 0x54, 0x41, 0x43, 0x4F), // "METACO"
        byteArrayOf(0x42, 0x4B, 0x53, 0x31, 0x32, 0x33), // BKS системы
        byteArrayOf(0x56, 0x49, 0x7A, 0x49, 0x54, 0x31), // VIZIT
        byteArrayOf(0x43, 0x79, 0x66, 0x72, 0x61, 0x6C), // Cyfral
        byteArrayOf(0x4B, 0x45, 0x59, 0x44, 0x4F, 0x4D), // KeyDom
        byteArrayOf(0x41, 0x42, 0x43, 0x44, 0x45, 0x46), // Стандартные последовательности
        byteArrayOf(0x12, 0x34, 0x56, 0x78, 0x9A.toByte(), 0xBC.toByte()),
        byteArrayOf(0x11, 0x11, 0x11, 0x11, 0x11, 0x11),
        byteArrayOf(0x22, 0x22, 0x22, 0x22, 0x22, 0x22),
        byteArrayOf(0x33, 0x33, 0x33, 0x33, 0x33, 0x33),
        byteArrayOf(0x77, 0x77, 0x77, 0x77, 0x77, 0x77),
        byteArrayOf(0x88.toByte(), 0x88.toByte(), 0x88.toByte(), 0x88.toByte(), 0x88.toByte(), 0x88.toByte()),
        byteArrayOf(0x99.toByte(), 0x99.toByte(), 0x99.toByte(), 0x99.toByte(), 0x99.toByte(), 0x99.toByte()),
        byteArrayOf(0xAA.toByte(), 0xAA.toByte(), 0xAA.toByte(), 0xAA.toByte(), 0xAA.toByte(), 0xAA.toByte()),
        byteArrayOf(0xBB.toByte(), 0xBB.toByte(), 0xBB.toByte(), 0xBB.toByte(), 0xBB.toByte(), 0xBB.toByte()),
        byteArrayOf(0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A),
        byteArrayOf(0xA5.toByte(), 0xA5.toByte(), 0xA5.toByte(), 0xA5.toByte(), 0xA5.toByte(), 0xA5.toByte())
    )
    private val basicKeys = listOf(
        // Claves por defecto más comunes
        byteArrayOf(0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte(), 0xFF.toByte()),
        byteArrayOf(0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
        byteArrayOf(0xA0.toByte(), 0xA1.toByte(), 0xA2.toByte(), 0xA3.toByte(), 0xA4.toByte(), 0xA5.toByte()),
        byteArrayOf(0xB0.toByte(), 0xB1.toByte(), 0xB2.toByte(), 0xB3.toByte(), 0xB4.toByte(), 0xB5.toByte()),
        byteArrayOf(0x4D, 0x3A, 0x99.toByte(), 0xC3.toByte(), 0x51, 0xDD.toByte()),
        byteArrayOf(0x1A, 0x98.toByte(), 0x2C, 0x7E, 0x45, 0x9A.toByte()),
        byteArrayOf(0xD3.toByte(), 0xF7.toByte(), 0xD3.toByte(), 0xF7.toByte(), 0xD3.toByte(), 0xF7.toByte()),
        byteArrayOf(0xAA.toByte(), 0xBB.toByte(), 0xCC.toByte(), 0xDD.toByte(), 0xEE.toByte(), 0xFF.toByte())
    )

    private val extendedKeys = listOf(
        // Claves de transporte público
        byteArrayOf(0x8F.toByte(), 0xD0.toByte(), 0xA4.toByte(), 0xF2.toByte(), 0x56, 0xE9.toByte()),
        byteArrayOf(0x74, 0x5C, 0xB9.toByte(), 0x39, 0xDA.toByte(), 0x90.toByte()),
        byteArrayOf(0x48, 0x45, 0x4C, 0x4C, 0x4F, 0x21),
        byteArrayOf(0x42, 0x52, 0x45, 0x41, 0x4B, 0x4D),
        byteArrayOf(0x4E, 0x46, 0x43, 0x4B, 0x45, 0x59),
        byteArrayOf(0x12, 0x34, 0x56, 0x78, 0x9A.toByte(), 0xBC.toByte()),
        byteArrayOf(0xFE.toByte(), 0xDC.toByte(), 0xBA.toByte(), 0x98.toByte(), 0x76, 0x54),
        byteArrayOf(0x11, 0x22, 0x33, 0x44, 0x55, 0x66),
        byteArrayOf(0x77, 0x88.toByte(), 0x99.toByte(), 0xAA.toByte(), 0xBB.toByte(), 0xCC.toByte()),
        byteArrayOf(0x01, 0x23, 0x45, 0x67, 0x89.toByte(), 0xAB.toByte())
    )

    private val transportKeys = listOf(
        byteArrayOf(0x8F.toByte(), 0xD0.toByte(), 0xA4.toByte(), 0xF2.toByte(), 0x56, 0xE9.toByte()),
        byteArrayOf(0x74, 0x5C, 0xB9.toByte(), 0x39, 0xDA.toByte(), 0x90.toByte()),
        byteArrayOf(0x48, 0x45, 0x4C, 0x4C, 0x4F, 0x21),
        byteArrayOf(0x42, 0x52, 0x45, 0x41, 0x4B, 0x4D),
        byteArrayOf(0x4E, 0x46, 0x43, 0x4B, 0x45, 0x59),
        byteArrayOf(0x12, 0x34, 0x56, 0x78, 0x9A.toByte(), 0xBC.toByte()),
        byteArrayOf(0xFE.toByte(), 0xDC.toByte(), 0xBA.toByte(), 0x98.toByte(), 0x76, 0x54),
        byteArrayOf(0x11, 0x22, 0x33, 0x44, 0x55, 0x66),
        byteArrayOf(0x77, 0x88.toByte(), 0x99.toByte(), 0xAA.toByte(), 0xBB.toByte(), 0xCC.toByte()),
        byteArrayOf(0x01, 0x23, 0x45, 0x67, 0x89.toByte(), 0xAB.toByte())
    )

    private val hotelKeys = listOf(
        byteArrayOf(0x31, 0x32, 0x33, 0x34, 0x35, 0x36),
        byteArrayOf(0x48, 0x4F, 0x54, 0x45, 0x4C, 0x31),
        byteArrayOf(0x52, 0x4F, 0x4F, 0x4D, 0x4B, 0x59),
        byteArrayOf(0x47, 0x55, 0x45, 0x53, 0x54, 0x31)
    )


    fun getBasicKeys(): List<ByteArray> = basicKeys

    fun getAllKeys(): List<ByteArray> = russianDomophoneKeys + basicKeys + transportKeys + extendedKeys + hotelKeys + generateVariations()

//    private fun generateVariations(): List<ByteArray> {
//        val variations = mutableListOf<ByteArray>()
//
//        // Generar variaciones numéricas
//        for (i in 0x00..0x0F) {
//            variations.add(byteArrayOf(i.toByte(), i.toByte(), i.toByte(), i.toByte(), i.toByte(), i.toByte()))
//        }
//
//        // Patrones comunes
//        variations.add(byteArrayOf(0x01, 0x02, 0x03, 0x04, 0x05, 0x06))
//        variations.add(byteArrayOf(0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F))
//        variations.add(byteArrayOf(0x10, 0x11, 0x12, 0x13, 0x14, 0x15))
//
//        return variations
//    }

    private fun generateVariations(): List<ByteArray> {
        val variations = mutableListOf<ByteArray>()

        // Генерация численных вариаций
        for (i in 0x00..0x0F) {
            variations.add(byteArrayOf(i.toByte(), i.toByte(), i.toByte(), i.toByte(), i.toByte(), i.toByte()))
        }

        // Общие паттерны
        variations.add(byteArrayOf(0x01, 0x02, 0x03, 0x04, 0x05, 0x06))
        variations.add(byteArrayOf(0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F))
        variations.add(byteArrayOf(0x10, 0x11, 0x12, 0x13, 0x14, 0x15))

        // Специфические российские паттерны
        for (i in 0x20..0x7F) {
            variations.add(byteArrayOf(i.toByte(), i.toByte(), i.toByte(), i.toByte(), i.toByte(), i.toByte()))
        }

        return variations
    }
}

