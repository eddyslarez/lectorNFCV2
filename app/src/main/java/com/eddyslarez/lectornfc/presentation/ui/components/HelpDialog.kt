package com.eddyslarez.lectornfc.presentation.ui.components


import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.eddyslarez.lectornfc.presentation.viewmodel.HelpTopic

@Composable
fun HelpDialog(
    topic: HelpTopic,
    onDismiss: () -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .fillMaxHeight(0.8f)
                .padding(16.dp),
            colors = CardDefaults.cardColors(containerColor = Color(0xFF2A2A2A))
        ) {
            Column(
                modifier = Modifier.padding(20.dp)
            ) {
                // T√≠tulo
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier.padding(bottom = 16.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Help,
                        contentDescription = null,
                        tint = Color(0xFF2196F3),
                        modifier = Modifier.size(24.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = getHelpTitle(topic),
                        fontSize = 20.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color.White
                    )
                }

                // Contenido scrolleable
                Column(
                    modifier = Modifier
                        .weight(1f)
                        .verticalScroll(rememberScrollState())
                ) {
                    HelpContent(topic = topic)
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Bot√≥n de cerrar
                Button(
                    onClick = onDismiss,
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = Color(0xFF2196F3)
                    )
                ) {
                    Text("Entendido")
                }
            }
        }
    }
}

@Composable
private fun HelpContent(topic: HelpTopic) {
    when (topic) {
        HelpTopic.READING -> ReadingHelp()
        HelpTopic.WRITING -> WritingHelp()
        HelpTopic.CRACKING -> CrackingHelp()
        HelpTopic.DICTIONARY_ATTACK -> DictionaryAttackHelp()
        HelpTopic.HARDNESTED_ATTACK -> HardnestedAttackHelp()
        HelpTopic.NONCE_ATTACK -> NonceAttackHelp()
        HelpTopic.MKF32_ATTACK -> MKF32AttackHelp()
        HelpTopic.EXPORT_DATA -> ExportDataHelp()
        HelpTopic.SECURITY_TIPS -> SecurityTipsHelp()
    }
}

@Composable
private fun ReadingHelp() {
    HelpSection(
        title = "üìñ Modo Lectura",
        content = """
            El modo lectura permite extraer informaci√≥n de tarjetas Mifare Classic.
            
            **C√≥mo usar:**
            1. Selecciona el modo "LEER"
            2. Acerca la tarjeta al dispositivo
            3. La aplicaci√≥n intentar√° leer todos los sectores
            4. Los datos se mostrar√°n en formato hexadecimal
            
            **Caracter√≠sticas:**
            ‚Ä¢ Lectura autom√°tica de todos los sectores
            ‚Ä¢ Detecci√≥n de claves conocidas
            ‚Ä¢ Visualizaci√≥n detallada de bloques
            ‚Ä¢ Identificaci√≥n de sectores de trailer
            
            **Consejos:**
            ‚Ä¢ Mant√©n la tarjeta estable durante la lectura
            ‚Ä¢ Algunos sectores pueden requerir claves espec√≠ficas
            ‚Ä¢ Los datos se guardan autom√°ticamente para escritura posterior
        """.trimIndent()
    )
}

@Composable
private fun WritingHelp() {
    HelpSection(
        title = "‚úèÔ∏è Modo Escritura",
        content = """
            El modo escritura permite copiar datos previamente le√≠dos a otra tarjeta.
            
            **C√≥mo usar:**
            1. Primero lee una tarjeta en modo lectura
            2. Selecciona el modo "ESCRIBIR"
            3. Acerca la tarjeta destino al dispositivo
            4. Los datos se escribir√°n autom√°ticamente
            
            **Importante:**
            ‚Ä¢ Solo se escriben bloques de datos, no trailers
            ‚Ä¢ Se requieren las claves correctas para escribir
            ‚Ä¢ El proceso es irreversible
            
            **Precauciones:**
            ‚ö†Ô∏è La escritura puede da√±ar la tarjeta si no se hace correctamente
            ‚ö†Ô∏è Aseg√∫rate de tener una copia de seguridad
            ‚ö†Ô∏è No interrumpas el proceso de escritura
        """.trimIndent()
    )
}

@Composable
private fun CrackingHelp() {
    HelpSection(
        title = "üîì Modo Crack",
        content = """
            El modo crack utiliza t√©cnicas avanzadas para descifrar claves de acceso.
            
            **M√©todos disponibles:**
            ‚Ä¢ **Diccionario**: Prueba claves conocidas
            ‚Ä¢ **Nonce**: Analiza patrones de comunicaci√≥n
            ‚Ä¢ **Hardnested**: Ataque criptogr√°fico avanzado
            ‚Ä¢ **MKF32**: Especializado en sistemas rusos
            ‚Ä¢ **Combinado**: Usa todos los m√©todos
            
            **Proceso:**
            1. Selecciona el m√©todo de ataque
            2. Acerca la tarjeta al dispositivo
            3. El ataque se ejecuta autom√°ticamente
            4. Las claves encontradas se muestran en tiempo real
            
            **Tiempo estimado:**
            ‚Ä¢ Diccionario: 1-5 minutos
            ‚Ä¢ Nonce: 2-10 minutos
            ‚Ä¢ Hardnested: 5-30 minutos
            ‚Ä¢ MKF32: 1-3 minutos
            ‚Ä¢ Combinado: 10-45 minutos
        """.trimIndent()
    )
}

@Composable
private fun DictionaryAttackHelp() {
    HelpSection(
        title = "üìö Ataque de Diccionario",
        content = """
            Prueba claves conocidas y comunes contra la tarjeta.
            
            **Diccionarios incluidos:**
            ‚Ä¢ Claves por defecto de fabricantes
            ‚Ä¢ Claves de sistemas de transporte p√∫blico
            ‚Ä¢ Claves de sistemas de dom√≥fonos rusos
            ‚Ä¢ Claves de sistemas hoteleros
            ‚Ä¢ Patrones num√©ricos comunes
            
            **Ventajas:**
            ‚úÖ R√°pido y eficiente
            ‚úÖ Alta tasa de √©xito en sistemas mal configurados
            ‚úÖ No requiere conocimientos t√©cnicos
            
            **Limitaciones:**
            ‚ùå Solo funciona con claves conocidas
            ‚ùå Inefectivo contra claves personalizadas
            
            **Consejos:**
            ‚Ä¢ Es el primer m√©todo recomendado
            ‚Ä¢ Funciona especialmente bien con dom√≥fonos
            ‚Ä¢ Comb√≠nalo con otros m√©todos para mejores resultados
        """.trimIndent()
    )
}

@Composable
private fun HardnestedAttackHelp() {
    HelpSection(
        title = "üî• Ataque Hardnested",
        content = """
            T√©cnica criptogr√°fica avanzada que explota debilidades en el cifrado Crypto-1.
            
            **C√≥mo funciona:**
            1. Requiere al menos una clave conocida
            2. Analiza la comunicaci√≥n entre lector y tarjeta
            3. Utiliza correlaciones criptogr√°ficas
            4. Deriva claves de otros sectores
            
            **Requisitos:**
            ‚Ä¢ Al menos una clave conocida (obtenida por diccionario)
            ‚Ä¢ Tarjeta compatible con Crypto-1
            ‚Ä¢ Tiempo de procesamiento considerable
            
            **Efectividad:**
            ‚Ä¢ Muy alta contra tarjetas vulnerables
            ‚Ä¢ Puede recuperar todas las claves
            ‚Ä¢ Funciona incluso con claves aleatorias
            
            **Proceso:**
            1. Ejecuta primero un ataque de diccionario
            2. Si encuentra al menos una clave, usa Hardnested
            3. El algoritmo derivar√° las claves restantes
            
            ‚ö†Ô∏è Este ataque puede tomar mucho tiempo
        """.trimIndent()
    )
}

@Composable
private fun NonceAttackHelp() {
    HelpSection(
        title = "üé≤ Ataque de Nonce",
        content = """
            Analiza los n√∫meros aleatorios (nonces) generados por la tarjeta.
            
            **Principio:**
            ‚Ä¢ Las tarjetas usan generadores de n√∫meros aleatorios
            ‚Ä¢ Algunos generadores tienen patrones predecibles
            ‚Ä¢ El an√°lisis estad√≠stico puede revelar las claves
            
            **T√©cnicas utilizadas:**
            ‚Ä¢ An√°lisis de frecuencia
            ‚Ä¢ Detecci√≥n de patrones temporales
            ‚Ä¢ Correlaci√≥n estad√≠stica
            ‚Ä¢ An√°lisis de entrop√≠a
            
            **Efectivo contra:**
            ‚Ä¢ Tarjetas con generadores d√©biles
            ‚Ä¢ Sistemas con implementaciones defectuosas
            ‚Ä¢ Clones de baja calidad
            
            **Limitaciones:**
            ‚Ä¢ Requiere m√∫ltiples lecturas
            ‚Ä¢ No funciona con generadores seguros
            ‚Ä¢ Puede dar falsos positivos
            
            **Indicadores de √©xito:**
            ‚Ä¢ Patrones repetitivos en nonces
            ‚Ä¢ Baja entrop√≠a en los datos
            ‚Ä¢ Correlaciones temporales
        """.trimIndent()
    )
}

@Composable
private fun MKF32AttackHelp() {
    HelpSection(
        title = "üîë Ataque MKF32",
        content = """
            Algoritmo especializado para sistemas de dom√≥fonos rusos.
            
            **Sistemas compatibles:**
            ‚Ä¢ Vizit
            ‚Ä¢ Cyfral
            ‚Ä¢ –ú–µ—Ç–∞–∫–æ–º (Metakom)
            ‚Ä¢ –ë–í–î (BVD)
            ‚Ä¢ Otros sistemas rusos
            
            **Algoritmos incluidos:**
            ‚Ä¢ **Enhanced**: Versi√≥n mejorada del MKF32
            ‚Ä¢ **Russian Domophone**: Espec√≠fico para dom√≥fonos
            ‚Ä¢ **Statistical**: Basado en an√°lisis estad√≠stico
            ‚Ä¢ **Adaptive**: Selecciona autom√°ticamente el mejor
            ‚Ä¢ **Cryptographic**: Usa funciones hash seguras
            
            **C√≥mo funciona:**
            1. Analiza el UID de la tarjeta
            2. Aplica transformaciones espec√≠ficas
            3. Genera claves candidatas
            4. Prueba las claves generadas
            
            **Ventajas:**
            ‚úÖ Muy efectivo contra sistemas rusos
            ‚úÖ R√°pido (1-3 minutos)
            ‚úÖ Alta tasa de √©xito
            
            **Consejos:**
            ‚Ä¢ Ideal para tarjetas de dom√≥fonos
            ‚Ä¢ Combina m√∫ltiples algoritmos
            ‚Ä¢ Funciona incluso con claves "aleatorias"
        """.trimIndent()
    )
}

@Composable
private fun ExportDataHelp() {
    HelpSection(
        title = "üì§ Exportar Datos",
        content = """
            Guarda los datos le√≠dos en diferentes formatos para an√°lisis posterior.
            
            **Formatos disponibles:**
            
            **TXT (Texto Plano)**
            ‚Ä¢ F√°cil de leer para humanos
            ‚Ä¢ Compatible con cualquier editor
            ‚Ä¢ Ideal para documentaci√≥n
            
            **JSON (JavaScript Object Notation)**
            ‚Ä¢ Formato estructurado
            ‚Ä¢ Compatible con aplicaciones web
            ‚Ä¢ F√°cil de procesar program√°ticamente
            
            **CSV (Comma Separated Values)**
            ‚Ä¢ Compatible con Excel
            ‚Ä¢ Ideal para an√°lisis estad√≠stico
            ‚Ä¢ Formato tabular
            
            **XML (eXtensible Markup Language)**
            ‚Ä¢ Est√°ndar para intercambio de datos
            ‚Ä¢ Compatible con muchas aplicaciones
            ‚Ä¢ Estructura jer√°rquica
            
            **Informaci√≥n incluida:**
            ‚Ä¢ Datos de todos los bloques
            ‚Ä¢ Claves encontradas
            ‚Ä¢ Informaci√≥n del UID
            ‚Ä¢ Timestamp del escaneo
            ‚Ä¢ Estad√≠sticas del proceso
            
            **Compartir:**
            ‚Ä¢ Email
            ‚Ä¢ WhatsApp
            ‚Ä¢ Telegram
            ‚Ä¢ Guardar en archivo
        """.trimIndent()
    )
}

@Composable
private fun SecurityTipsHelp() {
    HelpSection(
        title = "üõ°Ô∏è Consejos de Seguridad",
        content = """
            **Uso √âtico y Legal:**
            ‚ö†Ô∏è Solo usa esta herramienta en tarjetas de tu propiedad
            ‚ö†Ô∏è Respeta las leyes locales sobre seguridad inform√°tica
            ‚ö†Ô∏è No uses para actividades ilegales
            
            **Protecci√≥n de Datos:**
            ‚Ä¢ Los datos se almacenan localmente
            ‚Ä¢ No se env√≠a informaci√≥n a servidores externos
            ‚Ä¢ Borra los datos despu√©s del an√°lisis
            ‚Ä¢ Usa contrase√±as seguras para archivos exportados
            
            **Mejores Pr√°cticas:**
            ‚Ä¢ Mant√©n la aplicaci√≥n actualizada
            ‚Ä¢ Usa en entornos controlados
            ‚Ä¢ Documenta tus hallazgos
            ‚Ä¢ Reporta vulnerabilidades responsablemente
            
            **Protecci√≥n contra Ataques:**
            ‚Ä¢ Usa claves aleatorias de 6 bytes
            ‚Ä¢ Cambia claves por defecto
            ‚Ä¢ Implementa autenticaci√≥n adicional
            ‚Ä¢ Monitorea accesos no autorizados
            
            **Detecci√≥n de Vulnerabilidades:**
            ‚Ä¢ Prueba regularmente tus sistemas
            ‚Ä¢ Usa m√∫ltiples m√©todos de ataque
            ‚Ä¢ Documenta las debilidades encontradas
            ‚Ä¢ Implementa contramedidas apropiadas
            
            **Responsabilidad:**
            El usuario es responsable del uso de esta herramienta.
            √ösala solo para prop√≥sitos leg√≠timos de seguridad.
        """.trimIndent()
    )
}

@Composable
private fun HelpSection(
    title: String,
    content: String
) {
    Column {
        Text(
            text = title,
            fontSize = 18.sp,
            fontWeight = FontWeight.Bold,
            color = Color(0xFF4CAF50),
            modifier = Modifier.padding(bottom = 12.dp)
        )

        Text(
            text = content,
            fontSize = 14.sp,
            color = Color.White,
            lineHeight = 20.sp
        )
    }
}

private fun getHelpTitle(topic: HelpTopic): String {
    return when (topic) {
        HelpTopic.READING -> "Ayuda - Lectura"
        HelpTopic.WRITING -> "Ayuda - Escritura"
        HelpTopic.CRACKING -> "Ayuda - Cracking"
        HelpTopic.DICTIONARY_ATTACK -> "Ayuda - Ataque Diccionario"
        HelpTopic.HARDNESTED_ATTACK -> "Ayuda - Ataque Hardnested"
        HelpTopic.NONCE_ATTACK -> "Ayuda - Ataque Nonce"
        HelpTopic.MKF32_ATTACK -> "Ayuda - Ataque MKF32"
        HelpTopic.EXPORT_DATA -> "Ayuda - Exportar Datos"
        HelpTopic.SECURITY_TIPS -> "Consejos de Seguridad"
    }
}
